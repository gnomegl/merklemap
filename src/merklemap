#!/usr/bin/env bash

# @describe Search Merklemap certificate transparency database for SSL/TLS certificates
# @arg query "Search query (domain, subdomain, or certificate subject)" [string]
# @flag -h --help "Show help information"
# @option -p --page "Page number for pagination" [int] @default "0"
# @option -t --type "Search type (wildcard or distance)" [string] @default "wildcard"

# @flag -j --json "Output raw JSON response"
# @flag -q --quiet "Suppress colored output and progress indicators"
# @flag --no-header "Don't display header information"
# @flag --csv "Output results in CSV format"
# @flag --sort-date "Sort results by first_seen date (newest first)"
# @meta require-tools curl,jq

eval "$(argc --argc-eval "$0" "$@")"

set -euo pipefail

setup_colors() {
  if [ "${argc_quiet:-0}" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red="" white="" bg_yellow="" black=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) magenta=$(tput setaf 5) red=$(tput setaf 1)
    bg_yellow=$(tput setab 3) black=$(tput setaf 0)
  fi
}
setup_colors

# Color formatting functions
bold_text() {
  printf "${bold}%s${reset}" "$1"
}

red() {
  printf "${red}%s${reset}" "$1"
}

green() {
  printf "${green}%s${reset}" "$1"
}

yellow() {
  printf "${yellow}%s${reset}" "$1"
}

blue() {
  printf "${blue}%s${reset}" "$1"
}

cyan() {
  printf "${cyan}%s${reset}" "$1"
}

magenta() {
  printf "${magenta}%s${reset}" "$1"
}

highlight_match() {
  local text="$1"
  local query="$2"
  local color="$3"
  
  # Skip highlighting for distance searches
  if [ -z "$query" ] || [ "${argc_quiet:-0}" = "1" ] || [ "${argc_type:-}" = "distance" ]; then
    printf "%s" "$text"
    return
  fi
  
  # Convert wildcard pattern to regex
  # First escape special regex characters except * and .
  local regex_pattern=$(echo "$query" | sed 's/[][^$()+?{|]/\\&/g')
  # Then convert * to .* for wildcard matching
  regex_pattern=$(echo "$regex_pattern" | sed 's/\*/[^.]*/g')
  
  # Apply highlighting to matching portions only
  local result="$text"
  local highlighted=""
  local remaining="$text"
  
  # Use perl for better regex support if available, otherwise fallback to sed
  if command -v perl >/dev/null 2>&1; then
    # Perl gives us better control over highlighting - black text on yellow background
    highlighted=$(echo "$text" | perl -pe "s/($regex_pattern)/${reset}${bg_yellow}${black}${bold}\$1${reset}${color}/gi")
  else
    # Fallback to sed - black text on yellow background
    highlighted=$(echo "$text" | sed -E "s/($regex_pattern)/${reset}${bg_yellow}${black}${bold}&${reset}${color}/gi")
  fi
  
  printf "%s" "$highlighted"
}

make_request() {
  local query="$1"
  local page="$2"


  local url="https://api.merklemap.com/v1-webui/search-noauth"
  
  # Check if we're doing a distance search
  if [ "${argc_type:-}" = "distance" ]; then
    local response=$(curl -s --fail --max-time 30 "$url" \
      -G \
      --data-urlencode "query=$query" \
      --data-urlencode "page=$page" \
      --data-urlencode "size=1000" \
      --data-urlencode "type=distance" \
      --data-urlencode "_rsc=1hi0z")
  else
    local response=$(curl -s --fail --max-time 30 "$url" \
      -G \
      --data-urlencode "query=$query" \
      --data-urlencode "page=$page" \
      --data-urlencode "size=1000")
  fi

  if ! echo "$response" | jq -e . >/dev/null 2>&1; then
    printf "$(red "Error"): Invalid JSON response from API\n" >&2
    printf "Response: %s\n" "$response" >&2
    exit 1
  fi

  if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
    error_msg=$(echo "$response" | jq -r '.error // .message // "Unknown error"')
    printf "$(red "API Error"): %s\n" "$error_msg" >&2
    exit 1
  fi

  echo "$response"
}

show_help() {
  echo "$(bold_text "Merklemap Certificate Transparency Search")"
  echo ""
  echo "$(bold_text "Description"):"
  echo "  Search certificate transparency logs via Merklemap API for SSL/TLS certificates"
  echo ""
  echo "$(bold_text "Usage"):"
  echo "  $(green "$(basename "$0") <query> [options]")"
  echo "  $(green "$(basename "$0") --help")"
  echo ""
  echo "$(bold_text "Examples"):"
  echo "  $(green "$(basename "$0") example.com")"
  echo "  $(green "$(basename "$0") \"api.*.example.com\"")"
  echo "  $(green "$(basename "$0") revelo --type distance")"
  echo "  $(green "$(basename "$0") \"*.github.com\" --page 2")"
  echo ""
  echo "$(bold_text "Options"):"
  echo "  $(yellow "-t, --type")        Search type: wildcard (default) or distance"
  echo "  $(yellow "-p, --page")        Page number for pagination (default: 0)"

  echo "  $(yellow "-j, --json")        Output raw JSON response"
  echo "  $(yellow "-q, --quiet")       Suppress colored output"
  echo "  $(yellow "--no-header")       Don't display header information"
  echo "  $(yellow "--csv")             Output results in CSV format"
  echo "  $(yellow "--sort-date")       Sort results by first_seen date (newest first)"
  echo ""
  echo "$(bold_text "Notes"):"
  echo "  • Wildcard search (default) supports wildcard patterns and highlights matches"
  echo "  • Distance search performs fuzzy matching without highlighting"
  echo "  • Results include certificate subject names, hostnames, and first seen dates"
  echo "  • API endpoint: https://api.merklemap.com/v1-webui/search-noauth"
  echo "  • No authentication required for basic searches"
}

format_search_results() {
  local response="$1"
  local total=$(echo "$response" | jq -r '.count // 0')
  local results_count=$(echo "$response" | jq '.results | length')

  if [ "${argc_no_header:-0}" != "1" ] && [ "${argc_quiet:-0}" != "1" ]; then
    printf "$(bold_text "$(green "=== Merklemap Certificate Search Results ===")")\n"
    printf "$(yellow "Total Found"): %s certificates\n" "$total"
    printf "$(yellow "Showing"): %s results (page %s)\n" "$results_count" "${argc_page:-0}"
    printf "$(yellow "Query"): %s\n" "${argc_query:-}"
    printf "\n"
  fi

  if [ "$total" -eq 0 ]; then
    printf "$(yellow "No certificates found for query: ${argc_query:-}")\n"
    return 0
  fi

  local tmp_file=$(mktemp)

  if [ "${argc_sort_date:-0}" = "1" ]; then
    echo "$response" | jq -c '.results[] | . + {sort_date: (.first_seen | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime)}' | \
      sort -t'"' -k8 -nr | sed 's/,"sort_date":[0-9]*}/}/' > "$tmp_file"
  else
    echo "$response" | jq -c '.results[]' > "$tmp_file"
  fi

  while read -r cert; do
    hostname=$(echo "$cert" | jq -r '.hostname // "N/A"')
    subject_cn=$(echo "$cert" | jq -r '.subject_common_name // "N/A"')
    first_seen=$(echo "$cert" | jq -r '.first_seen // "N/A"')

    if [ "$first_seen" != "N/A" ] && [ "$first_seen" != "null" ]; then
      formatted_date=$(date -d "$first_seen" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$first_seen")
    else
      formatted_date="N/A"
    fi

    highlighted_hostname=$(highlight_match "$hostname" "${argc_query:-}" "$blue")
    printf "$(yellow "Hostname"): ${blue}%s${reset}\n" "$highlighted_hostname"

    if [ "$subject_cn" != "$hostname" ] && [ "$subject_cn" != "N/A" ]; then
      highlighted_subject_cn=$(highlight_match "$subject_cn" "${argc_query:-}" "$cyan")
      printf "$(yellow "Subject CN"): ${cyan}%s${reset}\n" "$highlighted_subject_cn"
    fi

    printf "$(yellow "First Seen"): %s\n" "$formatted_date"

    # Check if it's a wildcard certificate
    if [[ "$hostname" == \*.* ]] || [[ "$subject_cn" == \*.* ]]; then
      printf "$(yellow "Type"): $(magenta "Wildcard Certificate")\n"
    fi

    printf "\n"
  done < "$tmp_file"

  rm -f "$tmp_file"

  # Show pagination info
  if [ "${argc_quiet:-0}" != "1" ] && [ "$total" -gt 0 ]; then
    local size=1000
    local page="${argc_page:-0}"
    local current_start=$((page * size + 1))
    local current_end=$(((page + 1) * size))

    if [ "$current_end" -gt "$total" ]; then
      current_end="$total"
    fi

    printf "$(bold_text "$(yellow "Showing results $current_start-$current_end of $total")")\n"

    if [ "$current_end" -lt "$total" ]; then
      next_page=$((page + 1))
      printf "$(cyan "To see more results, use: --page $next_page")\n"
    fi
  fi
}

generate_csv() {
  local response="$1"
  printf "hostname,subject_common_name,first_seen\n"

  if [ "${argc_sort_date:-0}" = "1" ]; then
    echo "$response" | jq -r '.results[] | . + {sort_date: (.first_seen | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime)}' | \
      sort -t'"' -k8 -nr | jq -r '[.hostname, .subject_common_name, .first_seen] | @csv'
  else
    echo "$response" | jq -r '.results[] | [.hostname, .subject_common_name, .first_seen] | @csv'
  fi
}

do_search() {
  local query="${argc_query:-}"
  local page="${argc_page:-0}"


  if [ "${argc_quiet:-0}" != "1" ]; then
    printf "$(bold_text "$(cyan "Searching Merklemap certificate database...")")\n"
    printf "$(yellow "Query"): %s\n" "$query"
    printf "$(yellow "Type"): %s\n" "${argc_type:-wildcard}"
    printf "$(yellow "Page"): %s\n" "$page"
    printf "\n"
  fi

  local response=$(make_request "$query" "$page")

  if [ "${argc_json:-0}" = "1" ]; then
    echo "$response" | jq
    exit 0
  fi

  if [ "${argc_csv:-0}" = "1" ]; then
    generate_csv "$response"
    exit 0
  fi

  format_search_results "$response"
}

if [ "${argc_help:-0}" = "1" ]; then
  show_help
  exit 0
fi

if [ -z "${argc_query:-}" ]; then
  printf "$(red "Error"): Search query is required\n" >&2
  printf "\n"
  show_help
  exit 1
fi

do_search
