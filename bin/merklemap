#!/usr/bin/env bash

# @describe Search Merklemap certificate transparency database for SSL/TLS certificates
# @arg query "Search query (domain, subdomain, or certificate subject)" [string]
# @flag -h --help "Show help information"
# @option -p --page "Page number for pagination" [int] @default "0"

# @flag -j --json "Output raw JSON response"
# @flag -q --quiet "Suppress colored output and progress indicators"
# @flag --no-header "Don't display header information"
# @flag --csv "Output results in CSV format"
# @flag --sort-date "Sort results by first_seen date (newest first)"
# @meta require-tools curl,jq

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Search Merklemap certificate transparency database for SSL/TLS certificates

USAGE: merkelmap [OPTIONS] [QUERY]

ARGS:
  [QUERY]  "Search query (domain, subdomain, or certificate subject)" [string]

OPTIONS:
  -h, --help         "Show help information"
  -p, --page <PAGE>  "Page number for pagination" [int] @default "0"
  -j, --json         "Output raw JSON response"
  -q, --quiet        "Suppress colored output and progress indicators"
      --no-header    "Don't display header information"
      --csv          "Output results in CSV format"
      --sort-date    "Sort results by first_seen date (newest first)"
  -V, --version      Print version
EOF
    exit
}

_argc_version() {
    echo merkelmap 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --page | -p)
            _argc_take_args "--page <PAGE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_page:-}" ]]; then
                argc_page="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--page\` cannot be used multiple times"
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        --no-header)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--no-header\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_no_header:-}" ]]; then
                _argc_die "error: the argument \`--no-header\` cannot be used multiple times"
            else
                argc_no_header=1
            fi
            ;;
        --csv)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--csv\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_csv:-}" ]]; then
                _argc_die "error: the argument \`--csv\` cannot be used multiple times"
            else
                argc_csv=1
            fi
            ;;
        --sort-date)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--sort-date\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_sort_date:-}" ]]; then
                _argc_die "error: the argument \`--sort-date\` cannot be used multiple times"
            else
                argc_sort_date=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_query="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

set -euo pipefail

setup_colors() {
  if [ "${argc_quiet:-0}" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red="" white=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) magenta=$(tput setaf 5) red=$(tput setaf 1)
  fi
}
setup_colors

# Color formatting functions
bold_text() {
  printf "${bold}%s${reset}" "$1"
}

red() {
  printf "${red}%s${reset}" "$1"
}

green() {
  printf "${green}%s${reset}" "$1"
}

yellow() {
  printf "${yellow}%s${reset}" "$1"
}

blue() {
  printf "${blue}%s${reset}" "$1"
}

cyan() {
  printf "${cyan}%s${reset}" "$1"
}

magenta() {
  printf "${magenta}%s${reset}" "$1"
}

make_request() {
  local query="$1"
  local page="$2"


  local url="https://api.merklemap.com/v1-webui/search-noauth"
  local response=$(curl -s --fail --max-time 30 "$url" \
    -G \
    --data-urlencode "query=$query" \
    --data-urlencode "page=$page" \
    --data-urlencode "size=1000")

  if ! echo "$response" | jq -e . >/dev/null 2>&1; then
    printf "$(red "Error"): Invalid JSON response from API\n" >&2
    printf "Response: %s\n" "$response" >&2
    exit 1
  fi

  if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
    error_msg=$(echo "$response" | jq -r '.error // .message // "Unknown error"')
    printf "$(red "API Error"): %s\n" "$error_msg" >&2
    exit 1
  fi

  echo "$response"
}

show_help() {
  echo "$(bold_text "Merklemap Certificate Transparency Search")"
  echo ""
  echo "$(bold_text "Description"):"
  echo "  Search certificate transparency logs via Merklemap API for SSL/TLS certificates"
  echo ""
  echo "$(bold_text "Usage"):"
  echo "  $(green "$(basename "$0") <query>")"
  echo "  $(green "$(basename "$0") --help")"
  echo ""
  echo "$(bold_text "Examples"):"
  echo "  $(green "$(basename "$0") example.com")"
  echo "  $(green "$(basename "$0") \"api.*.example.com\"")"
  echo "  $(green "$(basename "$0") revelo")"
  echo "  $(green "$(basename "$0") \"*.github.com\" --page 2")"
  echo ""
  echo "$(bold_text "Options"):"
  echo "  $(yellow "-p, --page")        Page number for pagination (default: 0)"

  echo "  $(yellow "-j, --json")        Output raw JSON response"
  echo "  $(yellow "-q, --quiet")       Suppress colored output"
  echo "  $(yellow "--no-header")       Don't display header information"
  echo "  $(yellow "--csv")             Output results in CSV format"
  echo "  $(yellow "--sort-date")       Sort results by first_seen date (newest first)"
  echo ""
  echo "$(bold_text "Notes"):"
  echo "  • Search supports wildcard patterns and domain/subdomain queries"
  echo "  • Results include certificate subject names, hostnames, and first seen dates"
  echo "  • API endpoint: https://api.merklemap.com/v1-webui/search-noauth"
  echo "  • No authentication required for basic searches"
}

format_search_results() {
  local response="$1"
  local total=$(echo "$response" | jq -r '.count // 0')
  local results_count=$(echo "$response" | jq '.results | length')

  if [ "${argc_no_header:-0}" != "1" ] && [ "${argc_quiet:-0}" != "1" ]; then
    printf "$(bold_text "$(green "=== Merklemap Certificate Search Results ===")")\n"
    printf "$(yellow "Total Found"): %s certificates\n" "$total"
    printf "$(yellow "Showing"): %s results (page %s)\n" "$results_count" "${argc_page:-0}"
    printf "$(yellow "Query"): %s\n" "${argc_query:-}"
    printf "\n"
  fi

  if [ "$total" -eq 0 ]; then
    printf "$(yellow "No certificates found for query: ${argc_query:-}")\n"
    return 0
  fi

  local tmp_file=$(mktemp)

  if [ "${argc_sort_date:-0}" = "1" ]; then
    echo "$response" | jq -c '.results[] | . + {sort_date: (.first_seen | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime)}' | \
      sort -t'"' -k8 -nr | sed 's/,"sort_date":[0-9]*}/}/' > "$tmp_file"
  else
    echo "$response" | jq -c '.results[]' > "$tmp_file"
  fi

  while read -r cert; do
    hostname=$(echo "$cert" | jq -r '.hostname // "N/A"')
    subject_cn=$(echo "$cert" | jq -r '.subject_common_name // "N/A"')
    first_seen=$(echo "$cert" | jq -r '.first_seen // "N/A"')

    # Parse and format the date
    if [ "$first_seen" != "N/A" ] && [ "$first_seen" != "null" ]; then
      formatted_date=$(date -d "$first_seen" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$first_seen")
    else
      formatted_date="N/A"
    fi

    printf "$(yellow "Hostname"): $(blue "%s")\n" "$hostname"

    if [ "$subject_cn" != "$hostname" ] && [ "$subject_cn" != "N/A" ]; then
      printf "$(yellow "Subject CN"): $(cyan "%s")\n" "$subject_cn"
    fi

    printf "$(yellow "First Seen"): %s\n" "$formatted_date"

    # Check if it's a wildcard certificate
    if [[ "$hostname" == \*.* ]] || [[ "$subject_cn" == \*.* ]]; then
      printf "$(yellow "Type"): $(magenta "Wildcard Certificate")\n"
    fi

    printf "\n"
  done < "$tmp_file"

  rm -f "$tmp_file"

  # Show pagination info
  if [ "${argc_quiet:-0}" != "1" ] && [ "$total" -gt 0 ]; then
    local size=1000
    local page="${argc_page:-0}"
    local current_start=$((page * size + 1))
    local current_end=$(((page + 1) * size))

    if [ "$current_end" -gt "$total" ]; then
      current_end="$total"
    fi

    printf "$(bold_text "$(yellow "Showing results $current_start-$current_end of $total")")\n"

    if [ "$current_end" -lt "$total" ]; then
      next_page=$((page + 1))
      printf "$(cyan "To see more results, use: --page $next_page")\n"
    fi
  fi
}

generate_csv() {
  local response="$1"
  printf "hostname,subject_common_name,first_seen\n"

  if [ "${argc_sort_date:-0}" = "1" ]; then
    echo "$response" | jq -r '.results[] | . + {sort_date: (.first_seen | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime)}' | \
      sort -t'"' -k8 -nr | jq -r '[.hostname, .subject_common_name, .first_seen] | @csv'
  else
    echo "$response" | jq -r '.results[] | [.hostname, .subject_common_name, .first_seen] | @csv'
  fi
}

do_search() {
  local query="${argc_query:-}"
  if [ -z "$query" ]; then
    printf "$(red "Error"): Search query is required\n" >&2
    show_help
    exit 1
  fi


  local page="${argc_page:-0}"


  if [ "${argc_quiet:-0}" != "1" ]; then
    printf "$(bold_text "$(cyan "Searching Merklemap certificate database...")")\n"
    printf "$(yellow "Query"): %s\n" "$query"
    printf "$(yellow "Page"): %s\n" "$page"
    printf "\n"
  fi

  local response=$(make_request "$query" "$page")

  if [ "${argc_json:-0}" = "1" ]; then
    echo "$response" | jq
    exit 0
  fi

  if [ "${argc_csv:-0}" = "1" ]; then
    generate_csv "$response"
    exit 0
  fi

  format_search_results "$response"
}

if [ "${argc_help:-0}" = "1" ]; then
  show_help
  exit 0
fi

do_search
